# 최대 플로우
방향 그래프를 "플로우 네트워크" 로 해석 가능.  

## 표현
c(u,v) : 간선의 용량  
f(u,v) : 흐르는 플로우  
s : 출발점(source)  
t : 도착점(sink)  
|f| : s에 대해 (나가는 플로우 - 들어오는 플로우), sum(f(u,v))-sum(f(v,s))  

## 플로우 네트워크
용량은 음수가 아님. c(u,v) >= 0  
간선(u,v)가 존재하면 반대 방향 간선(v,u)가 존재하지 않음.  
s->v->t 경로가 포함  
s가 아닌 각 정점은 적어도 하나의 간선을 가짐.  |E| >= |V|-1
  
## 플로우(유량) 네트워크 속성
용량 제한 속성 : f(u,v) <= c(u,v) 자명한 속성, 각 간선의 유량은 해당 간선의 용량을 초과할수 없다. 흐르는 플로우는 용량을 넘지 않음.  
플로우 보존 : Σf(u,v)=0, 정점에 들어오는 플로우 == 나가는 플로우. 나가는 플로우는 양수, 들어오는 플로우는 음수로 표현.  
플로우의 대칭성 : f(u,v) = -f(v,u). v의 입장에서는 음수의 유량을 보내는 것으로 생각.  

## 다른 문제 모델링 방법
### 역평행 간선으로 모델링
주어진 그래프가 역평행 간선(반대 방향 간선)을 가질 경우. 즉, (u,v), (v,u) 간선이 존재하는 경우.  
플로우 네트워크에서는 반대 방향 간선을 가질 수 없다.  
그래서 역평행 간선에 대해 새로운 정점 w를 추가하여 
(u,v)간선은 그대로 두고, 
(v,u)간선을 (v,w), (w,u)로 한다.  
이유는 역평행 간선을 허용하지 않는 것(플로우 네트워크의 정의)이 문제 푸는데 편리함.  
  
### 다중 출발점과 도착점을 가진 네트워크
여러개의 출발점이나 도착점, 또는 둘다 가진 경우.  
단일 출발, 도착점을 가지도록 수정하여 플로우 네트워크를 만듬.  
가상의 한 정점을 만들고, 가상의 정점과 연결하는 용량을 무한대로 설정한다. c(s,s_i) = INF  

## 푸는 방법들
1. 포드-풀커슨 방법  
2. 무방향 이분 그래프 최대 매칭  
3. 푸시-재명명 알고리즘 (빠른 알고리즘의 기초)  

## 포드-풀커슨 방법
최초로 고안된 플로우 네트워크 알고리즘

### key 아이디어
1. 잔여 네트워크 G_f  
2. 증가 경로(augmenting path)  
3. 절단  

#### 잔여 네트워크 G_f
플로우를 어떻게 직관적으로 변경할 수 있는지를 나타내는 용량을 갖는 간선들로 구성된 네트워크.  
"잔여 용량 c_f"을 갖는 간선 추가한 네트워크.  
G_f는 G에 존재하지 않는 간선들도 포함되어 있음.  (플로우 대칭성 이용)  
플로우 네트워크랑 같은 특성을 가짐.  
잔여 네트워크의 플로우 f’는 기존 플로우 네트워크에 플로우를 더하는 것에 대한 지침 제공.  
f’에 의한 플로우 증강 (f↑f’)(u,v)  
f(u,v)이면, (f↑f’)(u,v) = f(u,v)+f’(u,v)-f’(v,u)  // 상쇄f’(v,u)는 역방향 간선에 플로우를 보내는 것.  
그 외 경우, (f↑f’)(u,v) = 0  

증강 적용한 플로우는 각 플로우의 합과 같다. |f↑f’| = |f|+|f’|  
|f↑f’|는 각 간선의 용량 제한(<=c(u,v))와 플로우 보존 특성을 따른다.  

최대 플로우를 구하기 위해서는   
1. 특정 플로우를 증가하거나,  
2. 특정 플로우를 감소해야함. (반대방향)  

##### 1. 특정 플로우 증가.
흘려 보낼 수 있는 플로우를 증가시킴.  
잔여 용량 c_f(u,v) = c(u,v)-f(u,v)  // 플로우를 증가 하기 위함. 흘려 보낼 수 있는 양을 표시.  

##### 2. 특정 플로우 감소.  
반대 방향으로 플로우를 증가시킴.  
총 플로우를 증가시키기 위해 특정 간선의 플로우를 감소시켜야 할 경우가 있다.  
가능한 감소를 나타내기 위해 G_f에 잔여용량c_f(v,u) = f(u,v)를 가진 간선(v,u)  
G_f에 반대 방향으로 최대 (u,v)의 플로우를 상쇄할 수 있는 플로우를 허용하는 간선을 추가.  
간선에 따라 플로우를 되돌려보내는 것은 그 간선에서 플로우를 감소시키는 것.  
c_f(u,v) = f(v,u) // 최대(u,v) 플로우를 감소시키기 위함.  플로우 대칭성  

잔여 용량 c_f(u,v)에 대해  
f(u,v) 일때, c_f(u,v)=c(u,v)-f(u,v)  
f(v,u) 일때, c_f(u,v)=f(v,u)  
그 외 경우, c_f(u,v)=0  //c_f(u,v) = 0인 간선은 G_f에서 제외(존재하지 않음)  

예를 들어, c(u,v)=16 f(u,v)=11 이면  
c_f(u,v)=16-11=5  // 5만큼 플로우를 증가 시켜 보낼 수 있음.  
c_f(v,u)=11       // 11만큼 플로우를 감소시켜서 최대 플로우를 구할 수 있음.  

|E_f| <= 2|E|  

### Code
```C++
for 각 간선 (u,v)
    (u,v).f = 0
while 잔여 네트워크 G_f에서 s->t로 가는 경로 p가 존재하면
    c_f(p) = min(경로p위에 간선)  // 병목 간선을 찾음
    for p에 있는 각 간선(u,v)
        if (u,v) ∈ E
            (u,v).f = (u,v).f - c_f(p)  // flow흐른만큼 빼줌 (잔여 flow)
        else
            (u,v).f = (u,v).f + c_f(p)  // flow흐른만큼 반대간선은 더함 (=더 흐를수 있는 간선, 대칭성)
```

## 에드몬드-카프 알고리즘
포드-풀커슨 방법을 이용한 알고리즘.  
dfs로 증강경로 구할때는 O(E*|f|) // dfs로 경로 찾는데 O(E), flow크기 만큼 반복.  
에드몬드-카프는 bfs로 최단 경로를 따라 증강경로를 구함으로써 O(VE^2)으로 개선. // flow 크기에 영향 받지 않고 가능.  
min(Ef, VE^2)만큼 걸림. // f가 최대 VE만큼 되기 때문.  
  
dfs와는 다르게 bfs를 사용하기 때문에 최단 경로 𝛅_f(u,v) 개념을 사용한다.  
(각 간선은 단위 거리)  

### 증명
#### 정리1. V-{s,t}인 모든 정점 v에 대해 각 플로우가 증가함에 따라 잔여 네트워크 G_f의 최단 경로 거리𝛅_f(s,v) 는 단조증가 한다.  
즉, 플로우 증강하면 𝛅_f(s,v)는 계속 증가한다.  

(가정)반대로 최단 거리를 감소시키는 플로우 증강이 존재한다면,  
f : 최단 경로 거리 감소시키는 첫 번째 플로우  
f': 플로우 증강 직후의 플로우  

𝛅_f'(s,v) < 𝛅_f(s,v)  // 가정의 의해 플로우 증강 후에 최단 거리 감소  

증강 한 직후에 보면,  
p = s~>u->v 가 G_f'에서 s에서 v로 가는 최단 경로라 하면, // 증강 직후 최단 경로  
(u,v) ∈ E_f' 이고,            // 경로 p에 간선이 존재  
𝛅_f'(s,u) = 𝛅_f'(s,v)-1 이다. // 경로 p에서 (u,v)간선이 포함되기 때문에 최단거리는 1 차이, 최단 경로에서 부분 집합도 최단경로.  

v를 선택하는 방법 때문에 s에서 u까지의 거리는 감소하지 않으므로,  // 이해 필요!!  
𝛅_f'(s,u) ≥ 𝛅_f(s,u)  

이때 (u,v) ∉ E_f 이다. 간선이 있다면 플로우 증강전이나 직후나 최단거리가 같기 때문에 가정에 모순이 된다.  

(u,v) ∉ E_f 이면서 (u,v) ∈ E_f'는 방법은 v에서 u로 플로우를 증강시켰을 때이다.  // 플로우 대칭성, 더 흐를 수 있는 간선이 추가됨.  
에드몬드-카프는 최단 경로를 따라 플로우를 증강하므로,  
(v,u)를 마지막 간선으로 가지는 G_f의 s에서 v까지 최단 경로로 증강했다는 것이다.  
𝛅_f(s,v) = 𝛅_f(s,u)-1 = 𝛅_f'(s,v)-2 // 𝛅_f'(s,u) = 𝛅_f'(s,v)-1 대입  
가정에 모순이 된다.  


#### 정리2. 반복 횟수 상한은 O(VE)이다.  
결정적(critical) : c_f(p) == c_f(u,v)인 간선 (u,v)  
플로우를 증강하고 나면 결정적 간선은 잔여 네트워크에서 사라진다.  
이러한 |E|개의 각 간선은 최대 |V|/2 번 결정적일 수 있다.  

key point  
잔여 네트워크에서 사라졌다가 다시 (u,v)간선이 나오는 경우는 (v,u)간선은 플로우 증강했을 경우이다. // 플로우 대칭성  
정리1에 의해 최단 거리는 계속 증가한다. // 감소가 없기 때문에 가능함.  

𝛿_f’(s,u) >= 𝛿_f(s,u) + 2 // 다시 결정적일때까지 적어도 거리 2 증가 (u,v)했다가(v,u)함.  
(s,u)의 최대거리는 |V| - 2   // 최단 경로 거리 |V| - 1 - {t}  
(u,v)가 첫 번째로 결정적이 된 후에 최대 (|V| - 2) / 2    // 다시 결정적일때 거리 2씩 증가하기 때문  


증강 경로를 찾는 반복이 |f|만큼 걸리는 대신 O(VE)만큼 걸린다.  

## 푸시-재명명 알고리즘
점근적으로 가장 빠른 알고리즘.  
에드몬드-카프 : O(VE^2) 보다 상한을 개선해서 O(V^2E), O(V^3) 시간에 수행.  

### 직관적인 통찰
저수지라는 개념으로 각 정점마다 초과된 양을 가지고 있고,  // 초과된 양이 저수지에 저장되어 있다고 생각.  
높이가 높은 곳에서 낮은 곳으로 flow를 보낸다.  // 알고리즘 진행할 수록 높이가 증가함.  
출발점에서 도착점까지 가능한 최대의 플로우를 보냄. 절단의 용량(절단을 가로지르는 양은 절단의 용량으로 제한)만큼 보낸다.  

### 동작 방법 차이   
포드-풀커슨 : 증강 경로 찾기 위해 전체 잔여 네트워크 탐색. // 증강 경로 하나씩..  
푸시-재명명 : 하나의 정점에서 잔여 네트워크에 있는 그 정점의 이웃을 살펴보는 방법.

### 필요한 정의
*선행 플로우(preflow)* : 용량 제약 조건과 완화된 플로우 보존의 법칙을 만족하는 flow.  
(용량 제약 조건 : flow는 capacity를 넘지 않는다. 더 많은 flow가 도착점에 흐르지 않게 함)  
(완화된 플로우 보존 조건 : 들어오는 flow가 나가는 flow보다 많다. 플로우 보존법칙 무시. ∑f(v,u)-∑f(u,v) ≥ 0)  
  
*초과 플로우* e(u) = ∑f(v,u)-∑f(u,v) // 선행 플로우 수치적 표현  
*오버 플로우* : 나가는 flow가 초과하는 flow, u ∈ V-{s,t} e(u) > 0.  

정점의 높이 h : 플로우를 밀어내는 방법을 결정. 높은 정점에서 낮은 정점으로 밀어낸다. 출발점=V, 도착점=0 고정.  
h(s)=|V|, h(t)=0, h(u)≤h(v)+1 // 이웃 정점들의 높이는 1칸 작을 수 있다(이떄 push 가능함)   
h(u)>h(v)+1이면, 즉 이웃 정점들의 높이가 2칸 이상 작으면 잔여 그래프의 간선이 아니다.  

### 기본 연산
push는 초과 플로우를 밀어 보내는 것.  
relabel은 정점의 높이를 갱신하는 것.  

#### Push
f가 선행 플로우라면 push 후에도 선행 플로우 유지.  
포화푸시 : 연산 후에 c_f(u,v)=0, 더 이상 보낼 수 없게 됨, 잔여 네트워크에서 사라짐.  
불포화푸시 : 그 외의 경우, 저수지 양만큼 보냄, 불포화푸시 후에 정점u는 오버플로우 상태가 아니게 된다.(u.e가 0이 되기 때문).  

```cpp
// 적용 시점: u가 오버플로우 정점, c_f(u,v)>0, h(u)=h(v)+1
// 연산 : u에서 v까지 ∆f(u,v)=min(u.e, c_f(u,v)) 단위의 플로우 push
∆f(u,v)=min(u.e, c_f(u,v))  // 보낼 수 있는 flow양 중 작은 값으로
                            // u.e : 보낼 수 있는 초과플로우 양, 저수지에 있는 양을 보냄, 불포화푸시(저수지 다 보냈는데 나중에 저수지 보충가능)
                            // c_f(u,v) : 보낼 수 있는 잔여 용량, 포화푸시(보낼 수 있는 양이 이제 없음=포화됨)
// 보낼 수 있는 flow만큼 보냄
if(u,v) ∈ E
    (u,v).f = (u,v).f+∆f(u,v) // 용량 제약 조건 만족
else
    (v,u).f = (v,u).f-∆f(u,v) // 대칭성
// 초과플로우 갱신
u.e = u.e-∆f(u,v) // flow보냈으니 저수지에 그만큼 줄어듬
v.e = v.e+∆f(u,v) // flow받았으니 저수지에 그만큼 추가
```

relabel : 포화 상태가 되지 않은 이웃 정점이 h(u)≤h(v) 상태에 있다. 오버플로우 정점u를 제거 하기 위해 정점의 높이를 높여줌  
