# 최대 플로우
방향 그래프를 "플로우 네트워크" 로 해석 가능.  

## 표현
c(u,v) : 간선의 용량  
f(u,v) : 흐르는 플로우  
s : 출발점(source)  
t : 도착점(sink)  
|f| : s에 대해 (나가는 플로우 - 들어오는 플로우), sum(f(u,v))-sum(f(v,s))  

## 플로우 네트워크
용량은 음수가 아님. c(u,v) >= 0  
간선(u,v)가 존재하면 반대 방향 간선(v,u)가 존재하지 않음.  
s->v->t 경로가 포함  
s가 아닌 각 정점은 적어도 하나의 간선을 가짐.  |E| >= |V|-1
  
## 플로우(유량) 네트워크 속성
용량 제한 속성 : f(u,v) <= c(u,v) 자명한 속성, 각 간선의 유량은 해당 간선의 용량을 초과할수 없다. 흐르는 플로우는 용량을 넘지 않음.  
플로우 보존 : Σf(u,v)=0, 정점에 들어오는 플로우 == 나가는 플로우. 나가는 플로우는 양수, 들어오는 플로우는 음수로 표현.  
플로우의 대칭성 : f(u,v) = -f(v,u). v의 입장에서는 음수의 유량을 보내는 것으로 생각.  

## 다른 문제 모델링 방법
### 역평행 간선으로 모델링
주어진 그래프가 역평행 간선(반대 방향 간선)을 가질 경우. 즉, (u,v), (v,u) 간선이 존재하는 경우.  
플로우 네트워크에서는 반대 방향 간선을 가질 수 없다.  
그래서 역평행 간선에 대해 새로운 정점 w를 추가하여 
(u,v)간선은 그대로 두고, 
(v,u)간선을 (v,w), (w,u)로 한다.  
이유는 역평행 간선을 허용하지 않는 것(플로우 네트워크의 정의)이 문제 푸는데 편리함.  
  
### 다중 출발점과 도착점을 가진 네트워크
여러개의 출발점이나 도착점, 또는 둘다 가진 경우.  
단일 출발, 도착점을 가지도록 수정하여 플로우 네트워크를 만듬.  
가상의 한 정점을 만들고, 가상의 정점과 연결하는 용량을 무한대로 설정한다. c(s,s_i) = INF  

## 푸는 방법들
1. 포드-풀커슨 방법  
2. 무방향 이분 그래프 최대 매칭  
3. 푸시-재명명 알고리즘 (빠른 알고리즘의 기초)  

## 포드-풀커슨 방법
최초로 고안된 플로우 네트워크 알고리즘

### key 아이디어
1. 잔여 네트워크 G_f  
2. 증가 경로(augmenting path)  
3. 절단  

#### 잔여 네트워크 G_f
플로우를 어떻게 직관적으로 변경할 수 있는지를 나타내는 용량을 갖는 간선들로 구성된 네트워크.  
"잔여 용량 c_f"을 갖는 간선 추가한 네트워크.  
G_f는 G에 존재하지 않는 간선들도 포함되어 있음.  (플로우 대칭성 이용)  
플로우 네트워크랑 같은 특성을 가짐.  
잔여 네트워크의 플로우 f’는 기존 플로우 네트워크에 플로우를 더하는 것에 대한 지침 제공.  
f’에 의한 플로우 증강 (f↑f’)(u,v)  
f(u,v)이면, (f↑f’)(u,v) = f(u,v)+f’(u,v)-f’(v,u)  // 상쇄f’(v,u)는 역방향 간선에 플로우를 보내는 것.  
그 외 경우, (f↑f’)(u,v) = 0  

증강 적용한 플로우는 각 플로우의 합과 같다. |f↑f’| = |f|+|f’|  
|f↑f’|는 각 간선의 용량 제한(<=c(u,v))와 플로우 보존 특성을 따른다.  

최대 플로우를 구하기 위해서는   
1. 특정 플로우를 증가하거나,  
2. 특정 플로우를 감소해야함. (반대방향)  

##### 1. 특정 플로우 증가.
흘려 보낼 수 있는 플로우를 증가시킴.  
잔여 용량 c_f(u,v) = c(u,v)-f(u,v)  // 플로우를 증가 하기 위함. 흘려 보낼 수 있는 양을 표시.  

##### 2. 특정 플로우 감소.  
반대 방향으로 플로우를 증가시킴.  
총 플로우를 증가시키기 위해 특정 간선의 플로우를 감소시켜야 할 경우가 있다.  
가능한 감소를 나타내기 위해 G_f에 잔여용량c_f(v,u) = f(u,v)를 가진 간선(v,u)  
G_f에 반대 방향으로 최대 (u,v)의 플로우를 상쇄할 수 있는 플로우를 허용하는 간선을 추가.  
간선에 따라 플로우를 되돌려보내는 것은 그 간선에서 플로우를 감소시키는 것.  
c_f(u,v) = f(v,u) // 최대(u,v) 플로우를 감소시키기 위함.  플로우 대칭성  

잔여 용량 c_f(u,v)에 대해  
f(u,v) 일때, c_f(u,v)=c(u,v)-f(u,v)  
f(v,u) 일때, c_f(u,v)=f(v,u)  
그 외 경우, c_f(u,v)=0  //c_f(u,v) = 0인 간선은 G_f에서 제외(존재하지 않음)  

예를 들어, c(u,v)=16 f(u,v)=11 이면  
c_f(u,v)=16-11=5  // 5만큼 플로우를 증가 시켜 보낼 수 있음.  
c_f(v,u)=11       // 11만큼 플로우를 감소시켜서 최대 플로우를 구할 수 있음.  

|E_f| <= 2|E|  

### Code
```C++
for 각 간선 (u,v)
    (u,v).f = 0
while 잔여 네트워크 G_f에서 s->t로 가는 경로 p가 존재하면
    c_f(p) = min(경로p위에 간선)  // 병목 간선을 찾음
    for p에 있는 각 간선(u,v)
        if (u,v) ∈ E
            (u,v).f = (u,v).f - c_f(p)  // flow흐른만큼 빼줌 (잔여 flow)
        else
            (u,v).f = (u,v).f + c_f(p)  // flow흐른만큼 반대간선은 더함 (=더 흐를수 있는 간선, 대칭성)
```

## 에드몬드-카프 알고리즘(=방법)
포드-풀커슨 방법을 이용한 알고리즘.  
dfs로 증강경로 구할때는 O(E*|f|) // dfs로 경로 찾는데 O(E), flow크기 만큼 반복.  
에드몬드-카프는 bfs로 최단 경로를 따라 증강경로를 구함으로써 O(VE^2)으로 개선. // flow 크기에 영향 받지 않고 가능.  
min(Ef, VE^2)만큼 걸림. // f가 최대 VE만큼 되기 때문.  
  
dfs와는 다르게 bfs를 사용하기 때문에 최단 경로 𝛅_f(u,v) 개념을 사용한다.  
(각 간선은 단위 거리)  

### 증명
#### 정리1. V-{s,t}인 모든 정점 v에 대해 각 플로우가 증가함에 따라 잔여 네트워크 G_f의 최단 경로 거리𝛅_f(s,v) 는 단조증가 한다.  
즉, 플로우 증강하면 𝛅_f(s,v)는 계속 증가한다.  

(가정)반대로 최단 거리를 감소시키는 플로우 증강이 존재한다면,  
f : 최단 경로 거리 감소시키는 첫 번째 플로우  
f': 플로우 증강 직후의 플로우  

𝛅_f'(s,v) < 𝛅_f(s,v)  // 가정의 의해 플로우 증강 후에 최단 거리 감소  

증강 한 직후에 보면,  
p = s~>u->v 가 G_f'에서 s에서 v로 가는 최단 경로라 하면, // 증강 직후 최단 경로  
(u,v) ∈ E_f' 이고,            // 경로 p에 간선이 존재  
𝛅_f'(s,u) = 𝛅_f'(s,v)-1 이다. // 경로 p에서 (u,v)간선이 포함되기 때문에 최단거리는 1 차이, 최단 경로에서 부분 집합도 최단경로.  

v를 선택하는 방법 때문에 s에서 u까지의 거리는 감소하지 않으므로,  // 이해 필요!!  
𝛅_f'(s,u) ≥ 𝛅_f(s,u)  

이때 (u,v) ∉ E_f 이다. 간선이 있다면 플로우 증강전이나 직후나 최단거리가 같기 때문에 가정에 모순이 된다.  

(u,v) ∉ E_f 이면서 (u,v) ∈ E_f'는 방법은 v에서 u로 플로우를 증강시켰을 때이다.  // 플로우 대칭성, 더 흐를 수 있는 간선이 추가됨.  
에드몬드-카프는 최단 경로를 따라 플로우를 증강하므로,  
(v,u)를 마지막 간선으로 가지는 G_f의 s에서 v까지 최단 경로로 증강했다는 것이다.  
𝛅_f(s,v) = 𝛅_f(s,u)-1 = 𝛅_f'(s,v)-2 // 𝛅_f'(s,u) = 𝛅_f'(s,v)-1 대입  
가정에 모순이 된다.  


#### 정리2. 반복 횟수 상한은 O(VE)이다.  
결정적(critical) : c_f(p) == c_f(u,v)인 간선 (u,v)  
플로우를 증강하고 나면 결정적 간선은 잔여 네트워크에서 사라진다.  
이러한 |E|개의 각 간선은 최대 |V|/2 번 결정적일 수 있다.  

key point  
잔여 네트워크에서 사라졌다가 다시 (u,v)간선이 나오는 경우는 (v,u)간선은 플로우 증강했을 경우이다. // 플로우 대칭성  
정리1에 의해 최단 거리는 계속 증가한다. // 감소가 없기 때문에 가능함.  

𝛿_f’(s,u) >= 𝛿_f(s,u) + 2 // 다시 결정적일때까지 적어도 거리 2 증가 (u,v)했다가(v,u)함.  
(s,u)의 최대거리는 |V| - 2   // 최단 경로 거리 |V| - 1 - {t}  
(u,v)가 첫 번째로 결정적이 된 후에 최대 (|V| - 2) / 2    // 다시 결정적일때 거리 2씩 증가하기 때문  


증강 경로를 찾는 반복이 |f|만큼 걸리는 대신 O(VE)만큼 걸린다.  
