# Fenwick Tree(= Binary Indexed Tree, BIT)
  
**동적인 누적 빈도수 테이블** 사용시 유용한 자료 구조  
Ex) 학생들의 시험 점수별로 빈도수가 어떻게 되는가?  
이진수 표현의 인덱스 사용  
비트연산  
0번 인덱스는 사용안함.  
  
공간 O(n)
시간 O(logN)  
  
배열을 트리로 만들기 : 구간트리 O(n) 펜윅트리 O(mlogn)  
동적인 구간 최소,최대 질의 : 구간트리 가능, 펜윅트리 매우 제한적  
동적인 구간 합 질의 : 둘다 가능  
질의별 복잡도 : 둘다 O(logn)  
원소 단위의 갱신 복잡도 : 둘다 O(logn)  
코드 길이 : 구간트리 길고, 펜윅트리 간단  
  
구간에 대한 이해  
i번 인덱스는 [i-LSOne(i)+1 .. i] 에 대한 내용을 담고 있다.  
{i-LSOne(i)+1,i-LSOne(i)+2,..,i} 에 대한 누적 빈도수가 저장.  
ft(4) => [4-4+1..4] = [1..4]  
ft(6) => [6-2+1..6] = [5..6]  
ft(7) => [7-1+1..7] = [7..7]  

  
bit의 마지막 1의 위치로 판단  
1의 위치가 높으면 아래 부분 다 포함 상태 -> 11|01, 11|10 => 11이라는 그룹에서 01(1개 누적), 10(2개 누적 01포함), 1100 (01,10,11 포함)
그룹의 시작은 1부터 -> 1100과 1101은 다른 그룹이고, 1101 부터 다시 1개 누적으로 시작  
  
  
13까지 합을 생각해보면  
서로 다른 그룹의 상위들의 덧셈 (위에서 부터 내려오면 최대단위로 묶임)  
13 = 1101 -> 3개의 1이 있음 -> index를 구하는데 1을 빼면서 구함 ( 1101 -> 1100 -> 1000 )  
  
  
  
```c++
// 누적값 업데이트, 밑에서 위로 업데이트
void update(int i, int num) {
    while (i <= n) {
        tree[i] += num;
        i += (i & -i);
    }
}
// 누적값에 대한 연산, 위에서 밑으로 연산
int sum(int i) {
    int ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= (i & -i);
    }
    return ans;
}
```
  
추가 참고 사이트  
https://www.acmicpc.net/blog/view/21
  
https://kks227.blog.me/220791986409?Redirect=Log&from=postView
